{"version":3,"file":"interfaces.js","sourceRoot":"","sources":["../../src/decorators/interfaces.ts"],"names":[],"mappings":"","sourcesContent":["import { Component, ComponentType, ComponentClass } from 'react'\nimport { Identifier } from 'dnd-core'\nimport {\n\tDropTargetMonitor,\n\tDragSourceMonitor,\n\tDragLayerMonitor,\n\tConnectDragPreview,\n\tConnectDropTarget,\n\tConnectDragSource,\n} from '../interfaces'\nimport { NonReactStatics } from 'hoist-non-react-statics'\n\n/**\n * A DnD interactive component\n */\nexport interface DndComponent<Props> extends Component<Props> {\n\tgetDecoratedComponentInstance(): Component<Props> | null\n\tgetHandlerId(): Identifier\n}\n\n/**\n * Interface for the DropTarget specification object\n */\nexport interface DropTargetSpec<Props> {\n\t/**\n\t * Optional.\n\t * Called when a compatible item is dropped on the target. You may either return undefined, or a plain object.\n\t * If you return an object, it is going to become the drop result and will be available to the drag source in its\n\t * endDrag method as monitor.getDropResult(). This is useful in case you want to perform different actions\n\t * depending on which target received the drop. If you have nested drop targets, you can test whether a nested\n\t * target has already handled drop by checking monitor.didDrop() and monitor.getDropResult(). Both this method and\n\t * the source's endDrag method are good places to fire Flux actions. This method will not be called if canDrop()\n\t * is defined and returns false.\n\t */\n\tdrop?: (props: Props, monitor: DropTargetMonitor, component: any) => any\n\n\t/**\n\t * Optional.\n\t * Called when an item is hovered over the component. You can check monitor.isOver({ shallow: true }) to test whether\n\t * the hover happens over just the current target, or over a nested one. Unlike drop(), this method will be called even\n\t * if canDrop() is defined and returns false. You can check monitor.canDrop() to test whether this is the case.\n\t */\n\thover?: (props: Props, monitor: DropTargetMonitor, component: any) => void\n\n\t/**\n\t * Optional. Use it to specify whether the drop target is able to accept the item. If you want to always allow it, just\n\t * omit this method. Specifying it is handy if you'd like to disable dropping based on some predicate over props or\n\t * monitor.getItem(). Note: You may not call monitor.canDrop() inside this method.\n\t */\n\tcanDrop?: (props: Props, monitor: DropTargetMonitor) => boolean\n}\n\nexport interface DragSourceSpec<Props, DragObject> {\n\t/**\n\t * Required.\n\t * When the dragging starts, beginDrag is called. You must return a plain JavaScript object describing the\n\t * data being dragged. What you return is the only information available to the drop targets about the drag\n\t * source so it's important to pick the minimal data they need to know. You may be tempted to put a reference\n\t * to the component into it, but you should try very hard to avoid doing this because it couples the drag\n\t * sources and drop targets. It's a good idea to return something like { id: props.id } from this method.\n\t */\n\tbeginDrag: (\n\t\tprops: Props,\n\t\tmonitor: DragSourceMonitor,\n\t\tcomponent: any,\n\t) => DragObject\n\n\t/**\n\t * Optional.\n\t * When the dragging stops, endDrag is called. For every beginDrag call, a corresponding endDrag call is guaranteed.\n\t * You may call monitor.didDrop() to check whether or not the drop was handled by a compatible drop target. If it was handled,\n\t * and the drop target specified a drop result by returning a plain object from its drop() method, it will be available as\n\t * monitor.getDropResult(). This method is a good place to fire a Flux action. Note: If the component is unmounted while dragging,\n\t * component parameter is set to be null.\n\t */\n\tendDrag?: (props: Props, monitor: DragSourceMonitor, component: any) => void\n\n\t/**\n\t * Optional.\n\t * Use it to specify whether the dragging is currently allowed. If you want to always allow it, just omit this method.\n\t * Specifying it is handy if you'd like to disable dragging based on some predicate over props. Note: You may not call\n\t * monitor.canDrag() inside this method.\n\t */\n\tcanDrag?: (props: Props, monitor: DragSourceMonitor) => boolean\n\n\t/**\n\t * Optional.\n\t * By default, only the drag source that initiated the drag operation is considered to be dragging. You can\n\t * override this behavior by defining a custom isDragging method. It might return something like props.id === monitor.getItem().id.\n\t * Do this if the original component may be unmounted during the dragging and later “resurrected” with a different parent.\n\t * For example, when moving a card across the lists in a Kanban board, you want it to retain the dragged appearance—even though\n\t * technically, the component gets unmounted and a different one gets mounted every time you move it to another list.\n\t *\n\t * Note: You may not call monitor.isDragging() inside this method.\n\t */\n\tisDragging?: (props: Props, monitor: DragSourceMonitor) => boolean\n}\n\n/**\n * DragSourceConnector is an object passed to a collecting function of the DragSource.\n * Its methods return functions that let you assign the roles to your component's DOM nodes.\n */\nexport interface DragSourceConnector {\n\t/**\n\t * Returns a function that must be used inside the component to assign the drag source role to a node. By\n\t * returning { connectDragSource: connect.dragSource() } from your collecting function, you can mark any React\n\t * element as the draggable node. To do that, replace any element with this.props.connectDragSource(element) inside\n\t * the render function.\n\t */\n\tdragSource(): ConnectDragSource\n\n\t/**\n\t * Optional. Returns a function that may be used inside the component to assign the drag preview role to a node. By\n\t * returning { connectDragPreview: connect.dragPreview() } from your collecting function, you can mark any React element\n\t * as the drag preview node. To do that, replace any element with this.props.connectDragPreview(element) inside the render\n\t * function. The drag preview is the node that will be screenshotted by the HTML5 backend when the drag begins. For example,\n\t * if you want to make something draggable by a small custom handle, you can mark this handle as the dragSource(), but also\n\t * mark an outer, larger component node as the dragPreview(). Thus the larger drag preview appears on the screenshot, but\n\t * only the smaller drag source is actually draggable. Another possible customization is passing an Image instance to dragPreview\n\t * from a lifecycle method like componentDidMount. This lets you use the actual images for drag previews. (Note that IE does not\n\t * support this customization). See the example code below for the different usage examples.\n\t */\n\tdragPreview(): ConnectDragPreview\n}\n\n/**\n * DropTargetConnector is an object passed to a collecting function of the DropTarget. Its only method dropTarget() returns a function\n * that lets you assign the drop target role to one of your component's DOM nodes.\n */\nexport interface DropTargetConnector {\n\t/**\n\t * Returns a function that must be used inside the component to assign the drop target role to a node.\n\t * By returning { connectDropTarget: connect.dropTarget() } from your collecting function, you can mark any React element\n\t * as the droppable node. To do that, replace any element with this.props.connectDropTarget(element) inside the render function.\n\t */\n\tdropTarget(): ConnectDropTarget\n}\n\nexport type DragSourceCollector<CollectedProps, TargetProps> = (\n\tconnect: DragSourceConnector,\n\tmonitor: DragSourceMonitor,\n\tprops: TargetProps,\n) => CollectedProps\n\nexport type DropTargetCollector<CollectedProps, TargetProps> = (\n\tconnect: DropTargetConnector,\n\tmonitor: DropTargetMonitor,\n\tprops: TargetProps,\n) => CollectedProps\n\nexport type DragLayerCollector<TargetProps, CollectedProps> = (\n\tmonitor: DragLayerMonitor,\n\tprops: TargetProps,\n) => CollectedProps\n\n// Borrowing typings from https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react-redux/index.d.ts\n\n// Omit taken from https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>\n\n/**\n * A property P will be present if:\n * - it is present in DecorationTargetProps\n *\n * Its value will be dependent on the following conditions\n * - if property P is present in InjectedProps and its definition extends the definition\n *   in DecorationTargetProps, then its definition will be that of DecorationTargetProps[P]\n * - if property P is not present in InjectedProps then its definition will be that of\n *   DecorationTargetProps[P]\n * - if property P is present in InjectedProps but does not extend the\n *   DecorationTargetProps[P] definition, its definition will be that of InjectedProps[P]\n */\nexport type Matching<InjectedProps, DecorationTargetProps> = {\n\t[P in keyof DecorationTargetProps]: P extends keyof InjectedProps\n\t\t? InjectedProps[P] extends DecorationTargetProps[P]\n\t\t\t? DecorationTargetProps[P]\n\t\t\t: InjectedProps[P]\n\t\t: DecorationTargetProps[P]\n}\n\n/**\n * a property P will be present if :\n * - it is present in both DecorationTargetProps and InjectedProps\n * - InjectedProps[P] can satisfy DecorationTargetProps[P]\n * ie: decorated component can accept more types than decorator is injecting\n *\n * For decoration, inject props or ownProps are all optionally\n * required by the decorated (right hand side) component.\n * But any property required by the decorated component must be satisfied by the injected property.\n */\nexport type Shared<InjectedProps, DecorationTargetProps> = {\n\t[P in Extract<\n\t\tkeyof InjectedProps,\n\t\tkeyof DecorationTargetProps\n\t>]?: InjectedProps[P] extends DecorationTargetProps[P]\n\t\t? DecorationTargetProps[P]\n\t\t: never\n}\n\n/**\n * Gets the props interface of a component using inference\n */\nexport type GetProps<C> = C extends ComponentType<infer P> ? P : never\n\nexport type DndComponentEnhancer<CollectedProps> = <\n\tC extends ComponentType<Matching<CollectedProps, GetProps<C>>>\n>(\n\tcomponent: C,\n) => DndComponentClass<\n\tC,\n\tOmit<GetProps<C>, keyof Shared<CollectedProps, GetProps<C>>>\n>\n\n// Applies LibraryManagedAttributes (proper handling of defaultProps\n// and propTypes), as well as defines WrappedComponent.\nexport type DndComponentClass<C extends ComponentType<any>, P> = ComponentClass<\n\tJSX.LibraryManagedAttributes<C, P>\n> &\n\tNonReactStatics<C> & { DecoratedComponent: C }\n"]}