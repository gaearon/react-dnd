{"version":3,"file":"wrapConnectorHooks.js","sourceRoot":"","sources":["../../src/common/wrapConnectorHooks.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAgB,MAAM,OAAO,CAAA;AACpD,OAAO,EAAE,YAAY,EAAE,MAAM,uBAAuB,CAAA;AAEpD,SAAS,gCAAgC,CAAC,OAA0B;IACnE,uEAAuE;IACvE,mEAAmE;IACnE,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,QAAQ,EAAE;QACrC,OAAM;KACN;IAED,MAAM,WAAW,GACf,OAAO,CAAC,IAAY,CAAC,WAAW,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,eAAe,CAAA;IAE1E,MAAM,IAAI,KAAK,CACd,sEAAsE;QACrE,uBAAuB,WAAW,mCAAmC;QACrE,sCAAsC,CACvC,CAAA;AACF,CAAC;AAED,SAAS,0BAA0B,CAAC,IAAuC;IAC1E,OAAO,CAAC,aAAa,GAAG,IAAI,EAAE,OAAO,GAAG,IAAI,EAAE,EAAE;QAC/C,mDAAmD;QACnD,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,EAAE;YACnC,MAAM,IAAI,GAAG,aAAa,CAAA;YAC1B,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;YACnB,uEAAuE;YACvE,kEAAkE;YAClE,OAAO,IAAI,CAAA;SACX;QAED,wEAAwE;QACxE,0EAA0E;QAC1E,iCAAiC;QACjC,MAAM,OAAO,GAAwB,aAAa,CAAA;QAClD,gCAAgC,CAAC,OAAc,CAAC,CAAA;QAEhD,oDAAoD;QACpD,MAAM,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,IAAa,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAA;QACnE,OAAO,YAAY,CAAC,OAAO,EAAE,GAAG,CAAC,CAAA;IAClC,CAAC,CAAA;AACF,CAAC;AAED,MAAM,UAAU,kBAAkB,CAAC,KAAU;IAC5C,MAAM,YAAY,GAAQ,EAAE,CAAA;IAE5B,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;QAClC,MAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,CAAA;QAEvB,iEAAiE;QACjE,IAAI,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;YACxB,YAAY,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAA;SAC9B;aAAM;YACN,MAAM,WAAW,GAAG,0BAA0B,CAAC,IAAI,CAAC,CAAA;YACpD,YAAY,CAAC,GAAG,CAAC,GAAG,GAAG,EAAE,CAAC,WAAW,CAAA;SACrC;IACF,CAAC,CAAC,CAAA;IAEF,OAAO,YAAY,CAAA;AACpB,CAAC","sourcesContent":["import { isValidElement, ReactElement } from 'react'\nimport { cloneWithRef } from '../utils/cloneWithRef'\n\nfunction throwIfCompositeComponentElement(element: ReactElement<any>) {\n\t// Custom components can no longer be wrapped directly in React DnD 2.0\n\t// so that we don't need to depend on findDOMNode() from react-dom.\n\tif (typeof element.type === 'string') {\n\t\treturn\n\t}\n\n\tconst displayName =\n\t\t(element.type as any).displayName || element.type.name || 'the component'\n\n\tthrow new Error(\n\t\t'Only native element nodes can now be passed to React DnD connectors.' +\n\t\t\t`You can either wrap ${displayName} into a <div>, or turn it into a ` +\n\t\t\t'drag source or a drop target itself.',\n\t)\n}\n\nfunction wrapHookToRecognizeElement(hook: (node: any, options: any) => void) {\n\treturn (elementOrNode = null, options = null) => {\n\t\t// When passed a node, call the hook straight away.\n\t\tif (!isValidElement(elementOrNode)) {\n\t\t\tconst node = elementOrNode\n\t\t\thook(node, options)\n\t\t\t// return the node so it can be chained (e.g. when within callback refs\n\t\t\t// <div ref={node => connectDragSource(connectDropTarget(node))}/>\n\t\t\treturn node\n\t\t}\n\n\t\t// If passed a ReactElement, clone it and attach this function as a ref.\n\t\t// This helps us achieve a neat API where user doesn't even know that refs\n\t\t// are being used under the hood.\n\t\tconst element: ReactElement | null = elementOrNode\n\t\tthrowIfCompositeComponentElement(element as any)\n\n\t\t// When no options are passed, use the hook directly\n\t\tconst ref = options ? (node: Element) => hook(node, options) : hook\n\t\treturn cloneWithRef(element, ref)\n\t}\n}\n\nexport function wrapConnectorHooks(hooks: any) {\n\tconst wrappedHooks: any = {}\n\n\tObject.keys(hooks).forEach((key) => {\n\t\tconst hook = hooks[key]\n\n\t\t// ref objects should be passed straight through without wrapping\n\t\tif (key.endsWith('Ref')) {\n\t\t\twrappedHooks[key] = hooks[key]\n\t\t} else {\n\t\t\tconst wrappedHook = wrapHookToRecognizeElement(hook)\n\t\t\twrappedHooks[key] = () => wrappedHook\n\t\t}\n\t})\n\n\treturn wrappedHooks\n}\n"]}